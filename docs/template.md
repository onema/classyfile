#Template

A custom template can be used. To set a new template simply use the `setTemplate` method and pass a closure or specify an instance of a class and a method to be called. The closure/method must return a string with the generated code. The following parameters will be passed to the invoked closure/method:

  - `$namespace`: namespace of the class.
  - `$useStatements`: all the use statements.
  - `$comments`: any comments placed above the class.
  - `$code`: the code generated by the PHP parser pretty printer for the current class.

The default template generates a [simple class](../src/Template/BasicClassTemplate.php). 


## Creating custom classes
You can create your own callable to create custom classes, this example will add the comment `/** Generated by My Name, name@domain.com */` at the top of each file: 


```php
$customComment = '/** Generated by My Name, name@domain.com */';
$customFunction = function ($namespace, $useStatements, $comments, $code) use ($customComment){
    return '<?php' . PHP_EOL.
    $customComment . PHP_EOL.
    $namespace . PHP_EOL.
    $useStatements . PHP_EOL.
    $comments . PHP_EOL.
    $code . PHP_EOL;});
    
$classyfile->setTemplate($customFunction);
```

> **NEW IN VERSION 1.0.0**
>
> A class can be used to get a template by using an instance of the class and specifying the method to be called. 
> This is an alternative of using a closure.

```php
class MyClassTemplate
{
    public function getTemplate ($namespace, $useStatements, $comments, $code)
    {
        $date = new \DateTime();
        $topComment = "/* Generated by ME on  {$date->format('Y/m/d')}*/";
        return '<?php' . PHP_EOL.
        $topComment . PHP_EOL.
        $namespace . PHP_EOL.
        $useStatements . PHP_EOL.
        $comments . PHP_EOL.
        $code . PHP_EOL;
    }
}
```

You can then set this class to and method to be called as follows:

```php
$classyfile->setTemplate(new MyClassTemplate(), 'getTemplate');
```
